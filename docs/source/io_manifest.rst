=====================
Input-output manifest
=====================

Examples
--------

Noise exposure
..............

Basic configuration of a system with one output (connectd to a speaker) and two inputs (from microphones) driven by a National Instruments DAQ card. This configuration is about as simple as it gets.

.. literalinclude:: ../../psi/templates/noise_exposure.enaml
    :language: enaml

Appetitive go-nogo behavior
...........................

Example configuration of a system designed for appetitive go-nogo behavior where the subject must nose-poke to start a trial and retrieve their reward from a food hopper. Both the nose-poke and food hopper have an infrared beam (photoemitter to photosensor) that generate an analog signal indicating the intensity of light falling on the photosensor. If the path between the photoemitter and photosensor is blocked (e.g., by the subject's nose), then the analog readout will reflect the change in light intensity. The analog readout of the photosensors are connected to the `nose_poke` and `reward_contact` channels.

For a go-nogo behavioral task, we need to convert this analog readout to a binary signal indicating whether the subject broke the infrared beam or not. In the following example we create a new processing chain, `AnalogToDigitalFilter` that performs this conversion and apply it to both the nose-poke and food hopper inputs.

.. literalinclude:: ../../psi/templates/gonogo_behavior.enaml
    :language: enaml

In the example code above, you'll note that we defined a `Toggle` output named `room_light_toggle`. If you look at the experiment manifest for appetitive experiments, you'll see that we've defined two actions that control this output:

.. code::
    :language: enaml

    ExperimentAction:
        event = 'to_start'
        command = 'room_light_toggle.off'

    ExperimentAction:
        event = 'to_end'
        command = 'room_light_toggle.on'

The `to_start` and `to_end` events are generated by the appetitive controller when a timeout begins and ends. The rules above result in turning off the room light when a timeout beings and turning it back on when the timeout ends. By creating a rules-based action system, it simplifies the process of ensuring that a sequence of actions occur 

In theory, we could configure the room light such that it was controlled by an Arduino if we had an Arduino backend implemented:

.. code::
    :language: enaml

    ArduinoEngine:
        DigitalOutput:
            name = 'room_light'
            channel = 'Pin1'

The engine is responsible for:

* Configuring the input and output channels.
* Responding to requests (e.g., uploading waveforms to analog output channels and toggling the state of digital output channels).
* Continuously pollign inptu channels and passing this through the input processing pipeline. All data acquisition is continuous (if you want epoch-based acquisition, you would add a special input, `ExtractEpochs`, to your input hierarchy).

You can have multiple engines in a single experiment.

from enaml.application import deferred_call
from enaml.layout.api import InsertItem
from enaml.widgets.api import Action
from enaml.workbench.api import Extension, ExtensionPoint, PluginManifest
from enaml.workbench.core.api import Command
from enaml.workbench.ui.api import ActionItem, MenuItem

from psi.experiment.api import Preferences
from ..util import rpc


def contribute_to_workspace(workbench, workspace):
    from .output_view import OutputDockItem
    plugin = workbench.get_plugin('psi.controller')
    item = OutputDockItem(workspace.dock_area, controller=plugin,
                          name='controller_outputs', title='Outputs')
    op = InsertItem(item=item.name, position='top')
    deferred_call(workspace.dock_area.update_layout, op)


enamldef ControllerManifest(PluginManifest): manifest:
    '''
    Defines the core functionality that most controller plugins will share
    (start, stop, pause, apply/revert settings).
    '''
    ExtensionPoint:
        id = 'psi.controller.io'

    ExtensionPoint:
        id = 'psi.controller.engines'

    Extension:
        id = 'commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = 'psi.controller.start'
            handler = rpc('psi.controller', 'start_experiment')
        Command:
            id = 'psi.controller.stop'
            handler = rpc('psi.controller', 'stop_experiment')
        Command:
            id = 'psi.controller.next_trial'
            handler = rpc('psi.controller', 'end_trial')
        Command:
            id = 'psi.controller.request_apply'
            handler = rpc('psi.controller', 'request_apply')
        Command:
            id = 'psi.controller.request_pause'
            handler = rpc('psi.controller', 'request_pause')
        Command:
            id = 'psi.controller.request_resume'
            handler = rpc('psi.controller', 'request_resume')

    # Uses unicode symbols as icons for sake of simplicity.
    Extension:
        id = 'toolbar'
        rank = 1
        point = 'psi.experiment.toolbar'
        Action:
            text = u'\u27A4 Start'
            tool_tip = 'Start experiment'
            triggered ::
                plugin = workbench.get_plugin('enaml.workbench.core')
                plugin.invoke_command('psi.controller.start')
            enabled << workbench.get_plugin('psi.controller').experiment_state \
                == 'initialized'
        Action:
            text = u'\u23F9 Stop'
            tool_tip = 'Stop experiment'
            triggered ::
                plugin = workbench.get_plugin('enaml.workbench.core')
                plugin.invoke_command('psi.controller.stop')
            enabled <<  workbench.get_plugin('psi.controller').experiment_state \
                not in ('initialized', 'stopped')
        Action:
            separator = True
        Action:
            text << u'\u23E9 Resume' if checked else u'\u23F8 Pause'
            checkable = True
            enabled <<  workbench.get_plugin('psi.controller').experiment_state \
                not in ('initialized', 'stopped')
            tool_tip << 'Resume' if checked else 'Pause'
            toggled ::
                plugin = workbench.get_plugin('enaml.workbench.core')
                if checked:
                    plugin.invoke_command('psi.controller.request_pause')
                else:
                    plugin.invoke_command('psi.controller.request_resume')
        Action:
            separator = True

        # Apply/Revert logic should pass through the controller so we can
        # ensure that the changes occur at the appropriate time in a trial
        # (i.e., in between trials). 
        Action:
            text = 'Apply'
            enabled << workbench.get_plugin('psi.context').changes_pending \
                and not workbench.get_plugin('psi.controller')._apply_requested \
                and workbench.get_plugin('psi.controller').experiment_state \
                in ('running', 'paused')
            triggered :: 
                plugin = workbench.get_plugin('enaml.workbench.core')
                plugin.invoke_command('psi.controller.request_apply')
        Action:
            text = 'Revert'
            enabled << workbench.get_plugin('psi.context').changes_pending \
                and workbench.get_plugin('psi.controller').experiment_state \
                in ('running', 'paused')
            triggered :: 
                plugin = workbench.get_plugin('enaml.workbench.core')
                plugin.invoke_command('psi.context.revert_changes')

    Extension:
        id = 'base_actions'
        point = 'enaml.workbench.ui.actions'
        MenuItem:
            path = '/equipment'
            label = 'Equipment'

    Extension:
        id = 'base_workspace'
        point = 'psi.experiment.workspace'
        factory = contribute_to_workspace

    Extension:
        id = 'preferences'
        point = 'psi.experiment.preferences'
        Preferences:
            get_preferences => (plugin):
                return dict((n, o._token_name) \
                            for n, o in plugin._outputs.items())

            set_preferences => (plugin, preferences):
                if preferences is None:
                    return
                for output_name, token_name in preferences.items():
                    plugin.configure_output(output_name, token_name)

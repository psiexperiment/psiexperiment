from pathlib import Path
import urllib.parse
import urllib.request

from atom.api import Atom, Bool, Enum, Float, List, observe, Property
from enaml.core.api import Looper
from enaml.layout.api import hbox, spacer, vbox
from enaml.widgets.api import (FileDialogEx, MainWindow, HGroup, Form, Label,
                               CheckBox, Container, VGroup, ObjectCombo, Field,
                               PushButton, Feature, ProgressBar, PopupView,
                               MenuBar, Menu, Action)

from enaml.stdlib.fields import FloatField, IntField
from psi.core.enaml.api import ListDictTable
from psi.data.io.abr import load
from psi.data.io.summarize_abr import is_processed, process_file
from psi.experiment.api import main_icon


enamldef ErrorPopup(PopupView): popup:

    anchor_mode = 'parent'
    anchor = (0, 0)
    offset = (0, 0)
    attr errors

    VGroup:
        Label:
            text = 'The following folders do not contain valid ABR data'
        Looper:
            iterable << errors[:]
            Label:
                text = str(loop_item)

        HGroup:
            leading_spacer = spacer(0)

            PushButton:
                text = 'OK'
                clicked :: popup.close()


def drop_data_to_abr_file_list(event):
    text = event.mime_data().data('text/uri-list').decode('utf-8')
    info = []
    errors = []
    for t in text.strip().split('\n'):
        t = urllib.parse.unquote(t).strip()
        fragments = urllib.parse.urlsplit(t)
        path = Path(urllib.request.url2pathname(fragments.path))
        try:
            fh = load(path)
            if fh.get_setting('digital_filter'):
                filter_info = '{} to {} Hz'.format(fh.get_setting('digital_highpass'),
                                                   fh.get_setting('digital_lowpass'))
            else:
                filter_info = 'No filtering'
            i = dict(path=path,
                     filename=path.name,
                     filter_info=filter_info,
                     reject_threshold=fh.get_setting('reject_threshold'),
                     averages=fh.get_setting('averages'),
                     ordering=fh.get_setting('ordering'),
                     rate=fh.get_setting('rate'))
            info.append(i)
        except:
            errors.append(path)
    return info, errors


class ProcessSettings(Atom):

    reprocess = Bool(False)
    time_lb = Float(-1e-3)
    time_ub = Float(9e-3)
    filter_mode = Enum('as defined in file', 'no filtering', 'manual')
    filter_lb = Float(300)
    filter_ub = Float(3000)
    info = List()

    offset = Property()
    duration = Property()
    filter_settings = Property()

    def _get_offset(self):
        return self.time_lb

    def _get_duration(self):
        return self.time_ub - self.time_lb

    def _get_filter_settings(self):
        if self.filter_mode == 'no filtering':
            return None
        if self.filter_mode == 'manual':
            return {'lb': self.filter_lb, 'ub': self.filter_ub}
        return 'saved'

    @observe('time_lb', 'time_ub', 'filter_mode', 'filter_lb', 'filter_ub',
             'info')
    def _check_processed(self, event):
        args = self.offset, self.duration, self.filter_settings
        for info in self.info:
            processed = is_processed(info['path'], *args)
            info['status'] = 'processed' if processed else 'unprocessed'

    def _process(self, progressbar):
        info = self.info[:]
        if not self.reprocess:
            info = [i for i in info if i['status'] != 'processed']

        args = self.offset, self.duration, self.filter_settings, self.reprocess
        progressbar.maximum = len(info)
        for j, i in enumerate(info):
            try:
                process_file(i['path'], *args)
                i['status'] = 'processed'
            except Exception as e:
                raise
                i['status'] = 'error'
                i['status_message'] = str(e)
            progressbar.value = j+1


enamldef SummarizeABRGui(MainWindow):

    initial_size = (800, 600)
    attr setting = ProcessSettings()
    attr files = []
    icon = main_icon

    MenuBar:
        Menu:
            title = '&File'
            Action:
                text = 'Add all from directory\tCtrl+O'
                triggered ::
                    directory = FileDialogEx.get_existing_directory()
                    if directory:
                        print('suceess')
            Action:
                text = 'Add all from directory (recursive)\tCtrl+R'
                triggered ::
                    directory = FileDialogEx.get_existing_directory()
                    if directory:
                        print('suceess')

    Container: container:
        features = Feature.DropEnabled

        drag_enter => (event):
            if event.mime_data().has_format('text/uri-list'):
                event.accept_proposed_action()

        drop => (event):
            info = setting.info.copy()
            new_info, errors = drop_data_to_abr_file_list(event)
            for i in new_info:
                if i not in info:
                    info.append(i)
            if errors:
                popup = ErrorPopup(container, errors=errors)
                popup.show()
            setting.info = info

        Container:
            constraints = [
                vbox(filter_form,
                     table,
                     progress,
                     hbox(spacer(0), reprocess, pb_process),
                     e_label,
                     e_message,
                     )
            ]

            Form: filter_form:
                padding = 0

                Label:
                    text = 'Filter'

                HGroup:
                    align_widths = False
                    padding = 0
                    spacing = 5
                    trailing_spacer = spacer(0)
                    ObjectCombo: filter_method:
                        items = list(setting.get_member('filter_mode').items)
                        selected := setting.filter_mode
                    FloatField: filter_lb:
                        value := setting.filter_lb
                        enabled << setting.filter_mode == 'manual'
                    Label:
                        text = 'to'
                    FloatField: filter_ub:
                        value := setting.filter_ub
                        enabled << setting.filter_mode == 'manual'
                    Label:
                        text = 'Hz'

                Label:
                    text = 'Analysis window'

                HGroup:
                    constraints = [
                        prestim.width == poststim.width,
                        prestim.width == 50,
                    ]
                    align_widths = False
                    padding = 0
                    spacing = 5
                    trailing_spacer = spacer(0)

                    FloatField: prestim:
                        value << setting.time_lb * 1e3
                        value ::
                            setting.time_lb = value * 1e-3
                    Label:
                        text = 'to'
                    FloatField: poststim:
                        value << setting.time_ub * 1e3
                        value ::
                            setting.time_ub = value * 1e-3
                    Label:
                        text = 'ms'

            ListDictTable: table:
                columns = ['filename', 'rate', 'ordering', 'averages',
                           'reject_threshold', 'filter_info']
                column_info = {
                    'rate': {'label': 'Rate'},
                    'ordering': {'label': 'Ordering'},
                    'averages': {'label': 'Averages'},
                    'filename': {'label': 'Filename'},
                    'reject_threshold': {'label': 'Reject threshold'},
                    'filter_info': {'label': 'Filter'},
                }
                header_resize_mode = 'contents'
                data << setting.info
                get_cell_color => (row, col):
                    status_map = dict(processed='lightgreen',
                                      unprocessed='white',
                                      error='lightpink')
                    return status_map[setting.info[row]['status']]
                select_behavior = 'rows'
                selection_changed ::
                    row = selected_coords[0][0]
                    e_message.text = setting.info[row].get('status_message', '')

            ProgressBar: progress:
                pass

            CheckBox: reprocess:
                text = 'Reprocess?'
                checked := setting.reprocess

            PushButton: pb_process:
                text = 'Process experiments'
                enabled << len(setting.info) != 0
                clicked ::
                    setting._process(progress)
                    table.update = True

            Label: e_label:
                text = 'Error detail'

            Label: e_message:
                pass

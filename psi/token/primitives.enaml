from __future__ import division

import logging
log = logging.getLogger(__name__)

from functools import wraps

import numpy as np
from scipy import signal
from joblib import Memory

from psi import get_config
from psi.context.api import Parameter, EnumParameter

from .block import EpochBlock, ContinuousBlock

# NOTE: For some functions, it's better not to cache as there is a "hit" from
# checking whether to load the results from disk or not.
cachedir = get_config('TEMP_ROOT')
memory = Memory(cachedir=cachedir, mmap_mode='r')


################################################################################
# Utility
################################################################################
def single_input(function):
    @wraps(function)
    def wrapper(*args, **kwargs):
        input_factories = kwargs.pop('input_factories')
        if len(input_factories) == 0:
            raise ValueError('Cannot deal with zero input factories')
        elif len(input_factories) > 1:
            raise ValueError('Cannot deal with more than one input factory')
        return function(*args, input_factory=input_factories[0], **kwargs)
    return wrapper


def no_inputs(function):
    @wraps(function)
    def wrapper(*args, **kwargs):
        input_factories = kwargs.pop('input_factories', [])
        if len(input_factories) != 0:
            raise ValueError('Cannot accept any input factories')
        return function(*args, **kwargs)
    return wrapper


def generate_waveform(generator, samples):
    generator.send(None)
    return generator.send({'samples': samples})[0]


################################################################################
# Cos2Envelope
################################################################################
def cos2envelope(fs, offset, samples, start_time, rise_time, duration):
    '''
    Generates cosine-squared envelope. Can handle generating fragments.
    '''
    def env_func(t, phi=0):
        return np.sin(2*np.pi*t*1.0/rise_time*0.25+phi)**2

    t = (np.arange(samples, dtype=np.float32) + offset)/fs

    m_null_pre = (t < start_time)
    m_onset = (t >= start_time) & (t < rise_time)

    # If duration is set to infinite, than we only apply an *onset* ramp.
    # This is used, in particular, for the DPOAE stimulus in which we want
    # to ramp on a continuous tone and then play it continuously until we
    # acquire a sufficient number of epochs.
    if duration != np.inf:
        m_offset = (t >= (start_time+duration-rise_time)) & \
            (t < (start_time+duration))
        m_null_post = t >= (duration+start_time)
    else:
        m_offset = np.zeros_like(t, dtype=np.bool)
        m_null_post = np.zeros_like(t, dtype=np.bool)

    t_null_pre = t[m_null_pre]
    t_onset = t[m_onset]
    t_offset = t[m_offset]
    t_ss = t[~(m_null_pre | m_onset | m_offset | m_null_post)]
    t_null_post = t[m_null_post]

    f_null_pre = np.zeros(len(t_null_pre))
    f_lower = env_func(t_onset, 0)
    f_upper = env_func(t_offset-(duration-rise_time), np.pi/2)
    f_middle = np.ones(len(t_ss))

    concat = [f_null_pre, f_lower, f_middle, f_upper]
    return np.concatenate(concat, axis=-1)


# TEST of a more easy to understand interface
#class Cos2Envelope:
#
#    def __init__(self, fs, start_time, rise_time, duration, calibration, child):
#        # TODO: Save
#
#    def reset(self):
#        self.epoch_samples = int(self.duration*self.fs)
#        self.offset = 0
#        self.complete = False
#        self.child.reset()
#
#    def next_samples(self, samples):
#        # Ensure we don't produce more samples than needed to complete waveform
#        samples = min(self.epoch_samples-self.offset, samples)
#
#        token = self.child.next_samples(samples)
#        envelope = cos2envelope(self.fs, self.offset, self.samples,
#                                self.start_time, self.rise_time, self.duration)
#        waveform = envelope*token
#        self.offset += len(waveform)
#
#        # Check if we're done
#        if self.offset == self.epoch_samples:
#            self.complete = True
#        elif self.offset > self.epoch_samples:
#            raise ValueError('Algorithm mistake!!')
#        else:
#            self.complete = False
#
#        return self.waveform, self.complete

@single_input
def cos2envelope_factory(fs, start_time, rise_time, duration, calibration,
                         input_factory):
    # Initialize some variables 
    waveform = None
    epoch_samples = int(duration*fs)
    offset = 0
    complete = False

    # Initialize the inputs
    input_generator = input_factory()
    next(input_generator)

    while True:
        # Provide waveform and wait on instructions for next waveform
        kwargs = (yield waveform, complete)

        # Ensure we don't produce more samples than needed to complete waveform
        samples = kwargs['samples']
        samples = min(epoch_samples-offset, samples)
        kwargs['samples'] = samples

        # Generate the waveform
        envelope = cos2envelope(fs, offset, samples, start_time, rise_time,
                                duration)
        token = input_generator.send(kwargs)[0]
        waveform = envelope*token
        offset += len(waveform)

        # Check if we're done
        if offset == epoch_samples:
            complete = True
        elif offset > epoch_samples:
            raise ValueError('Algorithm mistake!!')
        else:
            complete = False


enamldef Cos2Envelope(EpochBlock): block:

    factory = cos2envelope_factory
    name = 'envelope'
    label = 'envelope'

    get_duration => (context):
        block_context = self.get_block_context(context)
        return block_context['duration']

    Parameter:
        name = 'duration'
        label = 'duration (s)'
        compact_label = 'dur'
        default = 4.0

    Parameter:
        name = 'rise_time'
        label = 'rise time (s)'
        compact_label = 'env rise'
        default = 1.0

    Parameter:
        name = 'start_time'
        label = 'start time (s)'
        compact_label = 'start'
        default = 0.0


################################################################################
# SAM envelope
################################################################################
@memory.cache
def sam_eq_power(depth):
    return (3.0/8.0*depth**2.0-depth+1.0)**0.5


@memory.cache
def sam_eq_phase(delay, depth, direction):
    if depth == 0:
        return 0
    z = 2.0/depth*sam_eq_power(depth)-2.0/depth+1
    phi = np.arccos(z)
    return 2.0*np.pi-phi if direction == 1 else phi


def sam_envelope(offset, samples, fs, depth, fm, delay, direction):
    eq_phase = sam_eq_phase(delay, depth, direction)
    eq_power = sam_eq_power(depth)

    delay_n = np.clip(int(delay*fs)-offset, 0, samples)
    sam_n = samples-delay_n

    sam_offset = offset-delay_n
    t = (np.arange(sam_n, dtype=np.float32) + sam_offset)/fs
    sam_envelope = depth/2.0*np.cos(2.0*np.pi*fm*t+eq_phase)+1.0-depth/2.0

    # Ensure that we scale the waveform so that the total power remains equal
    # to that of an unmodulated token.
    sam_envelope *= 1.0/eq_power

    delay_envelope = np.ones(delay_n)
    return np.concatenate((delay_envelope, sam_envelope))


@single_input
def samenvelope_factory(fs, depth, fm, delay, direction, calibration,
                        input_factory):
    waveform = None
    offset = 0

    # Initialize the inputs
    input_generator = input_factory()
    next(input_generator)

    while True:
        kwargs = (yield waveform, False)
        samples = kwargs['samples']
        env = sam_envelope(offset, samples, fs, depth, fm, delay, direction)
        token = input_generator.send(kwargs)[0]
        waveform = env*token
        offset += len(waveform)


enamldef SAMEnvelope(ContinuousBlock): block:

    factory = samenvelope_factory
    name = 'SAM'
    label = 'SAM'

    Parameter:
        name = 'depth'
        label = 'depth (frac.)'
        compact_label = 'depth'
        default = 1.0

    Parameter:
        name = 'fm'
        label = 'Modulation frequency (Hz)'
        compact_label = 'fm'
        default = 5.0

    Parameter:
        name = 'delay'
        label = 'AM delay (s)'
        compact_label = 'delay'
        default = 0.0

    EnumParameter:
        name = 'direction'
        label = 'Initial AM direction'
        compact_label = 'dir'
        default = 'positive'
        choices = {'positive': 1, 'negative': -1}


################################################################################
# Bandlimited noise
################################################################################
@memory.cache
def _calculate_bandlimited_noise_filter(fs, fl, fh, fls, fhs,
                                        passband_attenuation,
                                        stopband_attenuation):
    Wp = np.array([fl, fh])/(0.5*fs)
    Ws = np.array([fls, fhs])/(0.5*fs)
    b, a = signal.iirdesign(Wp, Ws, passband_attenuation, stopband_attenuation) 
    if np.any(np.abs(np.roots(a)) >= 1):
        raise ValueError('Unstable filter coefficients')
    zi = signal.lfilter_zi(b, a)
    return b, a, zi


@memory.cache
def _calculate_bandlimited_noise_iir(fs, calibration, fl, fh):
    duration = 2.0/fl
    iir = calibration.get_iir(fs, fl, fh, duration)
    zi = signal.lfilter_zi(iir, [1])
    return iir, zi


@no_inputs
def bandlimited_noise_factory(fs, seed, level, fl, fh, filter_rolloff,
                              passband_attenuation, stopband_attenuation,
                              equalize, calibration):
    waveform = None
    state = np.random.RandomState(seed)

    center_frequency = (fl+fh)*0.5
    pass_bandwidth = fh-fl
    sf = calibration.get_sf(center_frequency, level)

    # Calculate the stop bandwidth as octaves above and below the passband.
    fls, fhs = fl*(2**-filter_rolloff), fh*(2**filter_rolloff)
    
    b, a, bp_zi = _calculate_bandlimited_noise_filter(fs, fl, fh, fls, fhs,
                                                      passband_attenuation,
                                                      stopband_attenuation)

    if equalize:
        iir, iir_zi = _calculate_bandlimited_noise_iir(fs, calibration, fl, fh)

    # This was copied from the EPL CFT. Need to figure out how this equation
    # works so we can document this better. But it works as intended to scale
    # the noise back to RMS=1.
    filter_sf = 1.0/np.sqrt(pass_bandwidth*2/fs/3.0)

    # The RMS value of noise drawn from a uniform distribution is
    # amplitude/sqrt(3). By setting the low and high to sqrt(3) and multiplying
    # by the scaling factors, we can ensure that the noise is initially
    # generated with the desired RMS.
    low, high = -np.sqrt(3)*filter_sf*sf, np.sqrt(3)*filter_sf*sf

    while True:
        kwargs = (yield waveform, False)
        samples = kwargs['samples']
        waveform = state.uniform(low=low, high=high, size=samples)
        if equalize:
            waveform, iir_zi = signal.lfilter(iir, [1], waveform, zi=iir_zi)
        waveform, bp_zi = signal.lfilter(b, a, waveform, zi=bp_zi)


enamldef BandlimitedNoise(ContinuousBlock):
    
    factory = bandlimited_noise_factory
    name = 'bandlimited_noise'
    label = 'bandlimited noise'

    Parameter:
        name = 'level'
        label = 'level (dB SPL)'
        compact_label = 'level'
        default = 60.0

    Parameter:
        name = 'seed'
        label = 'random seed'
        compact_label = 'seed'
        default = 1

    Parameter:
        name = 'fl'
        label = 'highpass cutoff (Hz)'
        compact_label = 'fl'
        default = 0.1e3

    Parameter:
        name = 'fh'
        label = 'lowpass cutoff (Hz)'
        compact_label = 'fh'
        default = 20e3

    Parameter:
        name = 'filter_rolloff'
        label = 'filter rolloff (octaves)'
        compact_label = 'fr'
        default = 3

    Parameter:
        name = 'passband_attenuation'
        label = 'passband attenuation (dB)'
        compact_label = 'pass. atten.'
        default = 0.1

    Parameter:
        name = 'stopband_attenuation'
        label = 'stopband attenuation (dB)'
        compact_label = 'stop. atten.'
        default = 90.0

    EnumParameter:
        name = 'equalize'
        default = 'yes'
        choices = {'yes': True, 'no': False}


################################################################################
# Tone
################################################################################
@no_inputs
def tone_factory(fs, level, frequency, phase, polarity, calibration):
    # Since the scaling factor is based on Vrms, we need to convert this to
    # the peak-to-peak scaling factor.
    sf = calibration.get_sf(frequency, level)*np.sqrt(2)
    waveform = None
    offset = 0
    while True:
        # Note. At least for 5 msec tones it's faster to just compute the array
        # rather than cache the result.
        kwargs = (yield waveform, False)
        samples = kwargs['samples']
        t = (np.arange(samples, dtype=np.float32) + offset)/fs
        waveform = polarity*sf*np.cos(2*np.pi*t*frequency + phase)
        offset += len(waveform)


enamldef Tone(ContinuousBlock):

    factory = tone_factory
    name = 'tone'
    label = 'tone'

    Parameter:
        name = 'level'
        label = 'level (dB SPL)'
        compact_label = 'level'
        default = 60.0

    Parameter:
        name = 'frequency'
        label = 'frequency (Hz)'
        compact_label = 'fc'
        default = 1000.0

    EnumParameter:
        name = 'polarity'
        label = 'polarity (radians)'
        compact_label = 'pol'
        default = 'positive'
        choices = {'positive': 1, 'negative': -1}

    Parameter:
        name = 'phase'
        label = 'phase'
        compact_label = 'Î˜'
        default = 0


################################################################################
# Silence
################################################################################
@no_inputs
def silence_factory(fs, calibration):
    waveform = None
    while True:
        kwargs = (yield waveform, False)
        samples = kwargs['samples']
        waveform = np.zeros(samples)


enamldef Silence(ContinuousBlock):

    factory = silence_factory
    name = 'silence'
    label = 'silence'



################################################################################
# Chirp
################################################################################
@no_inputs
def chirp_factory(fs, start_frequency, end_frequency, duration, level,
                  calibration):

    # In this particular example, we go ahead and pregenerate the chirp
    # waveform for simplictiy. This means that it won't support long-duration
    # chirps easily.
    waveform = None
    complete = False
    f0 = start_frequency
    f1 = end_frequency
    offset = 0

    n = int(fs*duration)
    t = np.arange(n, dtype=np.double) / fs
    k = (end_frequency-start_frequency)/duration

    # Compute instantaneous frequency, which can be used to compute the
    # instantaneous scaling factor for each timepoint (thereby compensating for
    # nonlinearities in the output).
    ifreq = t*k + start_frequency
    sf = calibration.get_sf(ifreq, level)*np.sqrt(2)

    # Now, compute the chirp
    chirp = sf*np.sin(2*np.pi*(start_frequency*t + k/2 * t**2))

    while True:
        kwargs = (yield waveform, complete)
        samples = kwargs['samples']
        waveform = chirp[offset:offset+samples]
        offset += len(waveform)
        n -= len(waveform)
        if n <= 0:
            complete = True


enamldef Chirp(EpochBlock):

    factory = chirp_factory
    name = 'chirp'
    label = 'chirp'

    get_duration => (context):
        block_context = self.get_block_context(context)
        return block_context['duration']

    Parameter:
        name = 'level'
        label = 'level (dB)'
        default = -40

    Parameter:
        name = 'start_frequency'
        label = 'start frequency (Hz)'
        default = 250.0

    Parameter:
        name = 'end_frequency'
        label = 'end frequency (Hz)'
        default = 50e3

    Parameter:
        name = 'duration'
        label = 'duration (sec)'
        default = 1/50.0

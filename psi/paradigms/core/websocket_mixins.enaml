import logging
log = logging.getLogger(__name__)

import asyncio
from functools import partial
import json
from threading import Thread
from urllib.parse import urlparse

from atom.api import set_default, Str, Typed, Value
from enaml.application import deferred_call
from enaml.workbench.api import Extension, Plugin
from enaml.workbench.core.api import Command
import websockets

from psi.controller.api import EventLogger, ExperimentAction
from psi.core.enaml.api import ExperimentManifest


def core_command_cb(core, mesg):
    core.invoke_command(mesg['command'], parameters=mesg.get('parameters', {}))


class MessageHandler:
    '''
    Basic message handler that sends/recieves messages between a client/server.
    This can be used by both the server and client. Handles shutdowns
    gracefully.
    '''

    def __init__(self, ws, send_queue, recv_cb, stop):
        self.ws = ws
        self.send_queue = send_queue
        self.recv_cb = recv_cb
        self.stop = stop

    async def send_handler(self):
        while True:
            mesg = await self.send_queue.get()
            log.info('Sending mesg via websocket: %r', mesg)
            await self.ws.send(mesg)

    async def recv_handler(self):
        while True:
            mesg = json.loads(await self.ws.recv())
            log.info('Recieved mesg from websocket: %r', mesg)
            self.recv_cb(mesg)

    async def stop_handler(self):
        await self.stop.wait()
        log.info('exiting')

    async def listen(self):
        try:
            log.info(f'Connect {self.ws}')
            send_task = asyncio.create_task(self.send_handler())
            recv_task = asyncio.create_task(self.recv_handler())
            stop_task = asyncio.create_task(self.stop_handler())
            await asyncio.wait([stop_task, send_task, recv_task],
                               return_when=asyncio.FIRST_COMPLETED)
            send_task.cancel()
            recv_task.cancel()
            try:
                await asyncio.gather(send_task, recv_task)
            except asyncio.CancelledError:
                pass
        except websockets.ConnectionClosedOK:
            log.info(f'Connection for %r closed', self.ws)
            stop_task.cancel()
            send_task.cancel()
            recv_task.cancel()
            try:
                await asyncio.gather(stop_task, send_task, recv_task)
            except asyncio.CancelledError:
                pass


class WebsocketServer:
    '''
    Manages a list of client connections. Each client has a separate
    MessageHandler for differentiation between the clients.
    '''
    def __init__(self, uri, loop, stop, send_queue, recv_cb):
        self.stop = stop
        self.send_queue = send_queue
        self.recv_cb = recv_cb
        self.clients = {}

        host, port = urlparse(uri).netloc.split(':')
        self.ws = websockets.serve(self.connect, host, port, loop=loop)
        loop.run_until_complete(self.ws)
        log.info(f'Websocket server listening on %s', uri)
        loop.run_until_complete(self.send_handler())

    async def send_handler(self):
        while True:
            client_id, mesg = json.loads(await self.send_queue.get())
            if client_id == 'broadcast':
                clients = self.clients.values()
            else:
                clients = [self.clients[client_id]]
            for client in clients:
                log.info('Sending mesg via %r: %r', client, mesg)
                client.put_nowait(json.dumps(mesg))

    async def connect(self, ws):
        send_queue = asyncio.Queue()
        comm = MessageHandler(ws, send_queue, self.recv_cb, self.stop)
        self.clients[ws] = send_queue
        await comm.listen()
        del self.clients[ws]


class WebsocketClient:

    def __init__(self, uri, loop, stop, send_queue, recv_cb):
        self.stop = stop
        self.send_queue = send_queue
        self.recv_cb = recv_cb

        self.ws = loop.run_until_complete(websockets.connect(uri, loop=loop))
        self.comm = MessageHandler(self.ws, send_queue, recv_cb, stop)

        log.info(f'Websocket client connected to %s', uri)
        loop.run_until_complete(self.comm.listen())
        loop.run_until_complete(self.ws.close())


class BaseWebsocketPlugin(Plugin):

    loop = Value()
    websocket_uri = Str('ws://localhost:8765')
    send_queue = Typed(asyncio.Queue, args=())
    thread = Typed(Thread)
    stop = Typed(asyncio.Event)

    def _default_loop(self):
        return asyncio.new_event_loop()

    def _default_stop(self):
        return asyncio.Event()

    def send_experiment_event(self, event):
        self._send_message(json.dumps(event.parameters['data']))

    def send_message(self, message):
        self._send_message(json.dumps(message))

    def _send_message(self, message):
        self.loop.call_soon_threadsafe(self.send_queue.put_nowait, message)

    def disconnect(self):
        deferred_call(self._disconnect)

    def _disconnect(self):
        log.info('Stop request recieved')
        self.loop.call_soon_threadsafe(self.stop.set)
        self.thread.join()
        log.info('Shut down websocket connection')


class WebsocketServerPlugin(BaseWebsocketPlugin):
    '''
    Sets up a server
    '''
    def start_thread(self, recv_cb):
        args = (self.websocket_uri, self.loop, self.stop, self.send_queue, recv_cb)
        self.thread = Thread(target=WebsocketServer, args=args, daemon=True)
        self.thread.start()

    def send_message(self, message, client_id='broadcast'):
        self._send_message(json.dumps([client_id, message]))


class WebsocketClientPlugin(BaseWebsocketPlugin):
    '''
    Sets up a client
    '''
    def start_thread(self, recv_cb):
        args = (self.websocket_uri, self.loop, self.stop, self.send_queue, recv_cb)
        self.thread = Thread(target=WebsocketClient, args=args, daemon=True)
        self.thread.start()


enamldef BaseWebsocketManifest(ExperimentManifest): manifest:
    '''
    Makes the WebSocket plugin available for communication

    When plugins are loaded into ps, the websocket server is started. All
    experiment events are sent via websockets.
    '''
    id = 'psi.websocket'

    Extension:
        id = 'websocket_commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = 'websocket.start'
            handler = lambda e: workbench.get_plugin('psi.websocket') \
                .start_thread(partial(core_command_cb, workbench.get_plugin('enaml.workbench.core')))

        Command:
            id = 'websocket.send_message'
            handler = lambda e: workbench.get_plugin('psi.websocket').send_message(e.parameters['message'])

        Command:
            id = 'websocket.send_experiment_event'
            handler = lambda e: workbench.get_plugin('psi.websocket').send_experiment_event(e)

        Command:
            id = 'websocket.disconnect'
            handler = lambda e: workbench.get_plugin('psi.websocket').disconnect()

    Extension:
        id = 'websocket_actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'plugins_started'
            command = 'websocket.start'

        EventLogger:
            command = 'websocket.send_experiment_event'

        ExperimentAction:
            event = 'window_closed'
            command = 'websocket.disconnect'


enamldef WebsocketServerManifest(BaseWebsocketManifest): manifest:
    '''
    Set up a websocket server for communication
    '''
    id = 'psi.websocket'
    factory = WebsocketServerPlugin


enamldef WebsocketClientManifest(BaseWebsocketManifest): manifest:
    '''
    Attempt to connect to websocket server for communication
    '''
    id = 'psi.websocket'
    factory = WebsocketClientPlugin
